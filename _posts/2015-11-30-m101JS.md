---
layout: post
title: "Takeaways from Mongo University"
date: 2015-11-30
---
Over the last 7 weeks, I worked through the MongoDB course for Node.js developers.  This is a free course offered online, and I learned a lot more than I expected.

Before I started the course, I knew that MongoDB was a NoSQL database system.  SQL databases, such as MySQL and PostgreSQL, use tables much like how Microsoft Excel appears, to represent and maintain persistent data.  MongoDB doesn't use that table system, and instead builds records based on JSON, or javasript Obect Notation. I could start a mongoD and mongo shell on my computer, and I had used Orchestrate on some projects. Orchestrate.io is a cloud based database system similar to Mongo, and is fairly easy to use. More of my time with databases had been spent with Postgresql, so I could insert data into a document, and configure a schema.

What I was hopeing to get out of the course was to become much more familiar and comfortable with crud operations.  CRUD are the operations for databases.  Create, Read, Update, Delete: Create a new record, query that record, make changes to that record, and remove that record from the database.  I really wanted to have a strong understanding on how to do something like create a user login, and over the period of the course I realized that I wanted to know more about Node.js and writing backend code.

Each week, at 9am on Tuesday, a slew of videos (ranging from 1 minute long to 12 minutes long) with short quizzes, and a few homework assignments (between 3 and 5) were made available on their learning management system.  The videos were on youtube, and there was a discussion view for students to post questions.  With most of the homework, there was evidence if the answer would be valid, and all the quizz answers were explained in detail.  On the final week, 10 questions were posted .  Throughout the course, some of the assessment was multiple choice, some used MongoProc (which ran tests on your database), and some required an answer or a validation code.

The first week was introduction.  Topics covered were installation, starting the MongoD instance, the Mongo shell, and an introducion to the Node Express server.

The second week covered CRUD.  With MongoDB, a query is called by the db.collection followed by an opperation.  From the shell, db is already specified since you are already in a database, which you can specify.  Collections are a group of records, or documents for Mongo.  A query searched through a collection and returns the documents that meet the query.  Documents can be Read with the find or findOne method, which works basically the same as the delete, or for Mongo the remove method.  Create (or the insert method for mongo) also works similar to the read method.  Updates a little more complicated, since a single update will remove the document and replace it with the fields that you specify.  To avoid this, the update query takes two parameters: the document you're querying, followed by the $set operator with the fields you want to change.  That's CRUD in a nutshell.

The third week covered schema design principals. Mongo has been considered schema-less, which means multiple documents in the same collection don't necessarily have to have the same columns like a sql db would.  Documents are javascript objects, so the properties of a document retain whatever values as desired, even embedded documents, such as arrays or other objects.  For example, in a collection that maintains blog posts, a single post can have an embedded property for comments made to that array with objects that contain properties such as the author of that comment on that post, the date the comment was made, and the contents of the post.  A lot has to be considered for the design of a schema.  Since schema's don't have to match, it's usually best if they don't match for a specific reason.

Week 4 covered performance.  This has to do with the time it takes for a query to return a given object or set of obects.  The time spent on a query, as indicated by how many documents the query looks at, can be reduced if indexes are approapriately used.  Every document has an _id field, and if not specified with one, is provided with one.  That field is indexed, meaning it's sorted in a specific way.  Other indexes can be created, and should resemble the types of queries the end user might make.  

Week 5 covered the aggregation pipeline.  Aggregation finds information relevate to the entire collection, such as the average grade a class has over a group of classes. The pipeline resembles more chaining, which in this case are objects with query opperators built on top of eachother.  

Week 6 covered application engineering, such as replication and sharding.  These are concerns for working with a large database system in the event that a database goes down and how collections recover from those failures.

In the 7th week, along with the final exam, there was content on Mongoose.  Mongoose is an ODB, and Object-Record-Mapper, which provides a layer on top from Mongo and Node and has some added functionality. These videos quickly walked through some code on how to crewate the same blog that the earlier weeks had done without the additional layer.

Since this course was for node developers, so there was code examples represented in an application, and I was really happy I had worked with node before because there were some huge leaps in what the homework expected students to do.  The quizzes that went with the vides checked for understanding at a very basic level, and the final examp mirrored the homework questions.  As for the discussion, I wish I had gotten more out of it.  I'm a fan of collaboration, so when I get stuck on a problem for a while, I'd like to be able to seek help without getting the answer.  If I get the answer without a lot of stuggle on my own, I'll probably forget what I learned. But some help is necessary.  There was some collaboration in the discussion board, but the Mongo Unversity doesn't want any code sharing, and the ta often came across defensive instead of helpful.  Still, the course was very interesting, and it kept my engagement even on the topics like indexes, sharding, and agggregation where I didn't feel like I had somewhere directly to apply what I had learned outside of the course.

For now, I want to get better at working with node.  I'm working through a course on [MEAN](https://www.edx.org/course/introduction-mongodb-using-mean-stack-mongodbx-m101x), which I hope to get a better understanding of how angular connects with node. This is a little ironic, since I'm working on an app with another developer and I've figured out where this happens.  Data is stored on the database, which is accessed from a service that connects to the backend api.  

Also, since I've expanded my understanding of NoSQL, I'm interested in SQL.  Codecademy has a tutorial on the subject, which I'll probably work through soon. I'd also like to read [MongoDB: The Definitive Guide](http://www.amazon.com/MongoDB-Definitive-Guide-Kristina-Chodorow/dp/1449344682/ref=sr_1_1?ie=UTF8&qid=1448932247&sr=8-1&keywords=mongodb).

I also recently found a new learning source. [Free Code Camp](http://www.freecodecamp.com/) has a fairly extensive sequence on stuff I should know, so I started working through it.  I'm finding gaps in my learning and doing a lot of review.  It's keeping me busy since I can't be as aggresive about looking for work now that I'm watching my son all day.  If a job comes my way, I'd love to work all day.  Until then, it's not so bad raising him.  Thanksgiving was a couple days ago.  I took a few days off from the computer and visited family in Las Vegas.

I got a lot out of this free course, and I would probably pay for it since it had the feedback.  If you want to take some time, I'd definately check it out.  They have courses specific to other languages as well.